---
sidebar_position: 2
title: "ROS 2 Basics (Nodes, Topics, Services)"
description: "Fundamentals of Robot Operating System 2 - Nodes, Topics, Services, and communication patterns"
slug: "/2-ros2-basics"
---

# ROS 2 Basics (Nodes, Topics, Services)

## Introduction to ROS 2

Robot Operating System 2 (ROS 2) is the next-generation framework for developing robotic applications. Unlike its predecessor, ROS 2 provides improved security, real-time support, and better cross-platform compatibility. It's built on DDS (Data Distribution Service) for robust communication between robotic components.

## Core Architecture Concepts

### Nodes
Nodes are the fundamental building blocks of ROS 2 applications. Each node is a process that performs specific computation and communicates with other nodes through topics, services, or actions.

```bash
# Example: Running a ROS 2 node
ros2 run turtlesim turtlesim_node
```

### Topics and Publishers/Subscribers
Topics enable asynchronous communication between nodes using a publish/subscribe pattern. Multiple nodes can publish to or subscribe from the same topic.

```python
# Python example: Creating a publisher
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello World: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1
```

```python
# Python example: Creating a subscriber
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)
```

### Services
Services provide synchronous request/response communication between nodes. A service client sends a request to a service server, which processes the request and returns a response.

```python
# Python example: Creating a service server
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalService(Node):
    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))
        return response
```

```python
# Python example: Creating a service client
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalClientAsync(Node):
    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()
```

## Common ROS 2 Commands

### Managing Nodes
```bash
# List all active nodes
ros2 node list

# Get information about a specific node
ros2 node info <node_name>

# Kill a specific node
ros2 node kill <node_name>
```

### Working with Topics
```bash
# List all active topics
ros2 topic list

# Show information about a topic
ros2 topic info /topic_name

# Echo messages from a topic
ros2 topic echo /topic_name

# Publish a message to a topic
ros2 topic pub /topic_name std_msgs/String "data: 'Hello World'"
```

### Working with Services
```bash
# List all active services
ros2 service list

# Show information about a service
ros2 service info /service_name

# Call a service
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 1, b: 2}"
```

## Parameters
ROS 2 nodes can have configurable parameters that can be set at launch time or changed during runtime:

```bash
# List parameters of a node
ros2 param list <node_name>

# Get a parameter value
ros2 param get <node_name> <param_name>

# Set a parameter value
ros2 param set <node_name> <param_name> <value>
```

## Actions
Actions are used for long-running tasks with feedback and goal management:

```python
# Python example: Action server
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])

            goal_handle.publish_feedback(feedback_msg)

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        return result
```

## Launch Files
Launch files allow you to start multiple nodes simultaneously with specific configurations:

```xml
<!-- example_launch.py -->
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='turtlesim',
            executable='turtlesim_node',
            name='sim'
        ),
        Node(
            package='turtlesim',
            executable='turtle_teleop_key',
            name='teleop'
        )
    ])
```

## Best Practices

1. **Node Design**: Keep nodes focused on a single responsibility
2. **Topic Naming**: Use descriptive names and follow conventions (e.g., `/robot_name/sensor_name`)
3. **Message Types**: Use appropriate message types for your data
4. **Error Handling**: Implement proper error handling in all communication patterns
5. **Resource Management**: Clean up resources properly in node destruction

## Summary

ROS 2 provides a robust framework for building complex robotic systems through its node-based architecture and various communication patterns. Understanding nodes, topics, services, and actions is crucial for developing effective robotic applications. The next chapter will explore how to use simulation environments to test and develop these systems before deploying them on real hardware.