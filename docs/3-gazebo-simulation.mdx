---
sidebar_position: 3
title: "Simulating with Gazebo (World Creation, Physics)"
description: "Using Gazebo simulation environment for robotics development - world creation, physics modeling, and sensor simulation"
slug: "/3-gazebo-simulation"
---

# Simulating with Gazebo (World Creation, Physics)

## Introduction to Gazebo

Gazebo is a powerful 3D simulation environment that provides realistic physics simulation, high-quality graphics, and sensor simulation for robotics development. It's widely used in the robotics community for testing algorithms, validating control systems, and training AI models before deployment on real robots.

## Installing and Setting Up Gazebo

### Prerequisites
```bash
# Install Gazebo (this example uses Gazebo Garden)
sudo apt-get install ros-humble-gazebo-ros-pkgs
```

### Basic Gazebo Launch
```bash
# Launch Gazebo with empty world
gazebo

# Launch Gazebo with ROS 2 integration
ros2 launch gazebo_ros gazebo.launch.py
```

## World Creation

### Basic World Structure
Gazebo worlds are defined using SDF (Simulation Description Format) files. Here's a minimal world file:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="default">
    <!-- Include a model from the model database -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Include the sun -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- Your custom models go here -->
    <model name="my_robot">
      <!-- Model definition -->
    </model>
  </world>
</sdf>
```

### Creating Custom Worlds
Let's create a more complex world with custom elements:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="my_warehouse">
    <!-- Physics engine configuration -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000.0</real_time_update_rate>
    </physics>

    <!-- Environment lighting -->
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.6 0.4 -0.8</direction>
    </light>

    <!-- Ground plane -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- Custom floor with texture -->
    <model name="floor">
      <static>true</static>
      <link name="floor_link">
        <collision name="floor_collision">
          <geometry>
            <box>
              <size>10 10 0.1</size>
            </box>
          </geometry>
        </collision>
        <visual name="floor_visual">
          <geometry>
            <box>
              <size>10 10 0.1</size>
            </box>
          </geometry>
          <material>
            <ambient>0.7 0.7 0.7 1</ambient>
            <diffuse>0.7 0.7 0.7 1</diffuse>
            <specular>0.1 0.1 0.1 1</specular>
          </material>
        </visual>
      </link>
    </model>

    <!-- Obstacles -->
    <model name="wall_1">
      <pose>0 4 0.5 0 0 0</pose>
      <static>true</static>
      <link name="wall_link">
        <collision name="wall_collision">
          <geometry>
            <box>
              <size>10 0.2 1</size>
            </box>
          </geometry>
        </collision>
        <visual name="wall_visual">
          <geometry>
            <box>
              <size>10 0.2 1</size>
            </box>
          </geometry>
        </visual>
      </link>
    </model>

    <!-- Add a simple robot -->
    <model name="simple_robot">
      <pose>0 0 0.2 0 0 0</pose>
      <link name="chassis">
        <pose>0 0 0.1 0 0 0</pose>
        <collision name="collision">
          <geometry>
            <box>
              <size>0.5 0.5 0.2</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.5 0.5 0.2</size>
            </box>
          </geometry>
        </visual>
        <inertial>
          <mass>1.0</mass>
          <inertia>
            <ixx>0.01</ixx>
            <ixy>0</ixy>
            <ixz>0</ixz>
            <iyy>0.01</iyy>
            <iyz>0</iyz>
            <izz>0.01</izz>
          </inertia>
        </inertial>
      </link>
    </model>
  </world>
</sdf>
```

### Loading Custom Worlds
```bash
# Launch Gazebo with your custom world
gazebo ~/.gazebo/worlds/my_warehouse.world

# Or launch via ROS 2
ros2 launch gazebo_ros gazebo.launch.py world:=/path/to/my_world.sdf
```

## Physics Simulation

### Physics Engines
Gazebo supports multiple physics engines:

- **ODE (Open Dynamics Engine)**: Default, good for most applications
- **Bullet**: Fast, good for real-time simulation
- **DART**: Advanced physics, good for complex interactions
- **Simbody**: Multi-body dynamics

### Physics Configuration
Physics parameters significantly affect simulation accuracy and performance:

```xml
<physics type="ode">
  <!-- Time step for simulation -->
  <max_step_size>0.001</max_step_size>

  <!-- Real-time factor (1.0 = real-time, >1.0 = faster than real-time) -->
  <real_time_factor>1.0</real_time_factor>

  <!-- Update rate (Hz) -->
  <real_time_update_rate>1000.0</real_time_update_rate>

  <!-- Solver parameters -->
  <ode>
    <solver>
      <type>quick</type>
      <iters>10</iters>
      <sor>1.3</sor>
    </solver>
    <constraints>
      <cfm>0.0</cfm>
      <erp>0.2</erp>
      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
      <contact_surface_layer>0.001</contact_surface_layer>
    </constraints>
  </ode>
</physics>
```

### Material Properties
Material properties affect how objects interact:

```xml
<material>
  <ambient>0.3 0.3 0.3 1</ambient>
  <diffuse>0.7 0.7 0.7 1</diffuse>
  <specular>0.1 0.1 0.1 1</specular>
  <emissive>0 0 0 1</emissive>
</material>
```

## Sensor Simulation

### Camera Sensors
```xml
<sensor name="camera" type="camera">
  <pose>0.1 0 0.1 0 0 0</pose>
  <camera name="head">
    <horizontal_fov>1.047</horizontal_fov>
    <image>
      <width>640</width>
      <height>480</height>
      <format>R8G8B8</format>
    </image>
    <clip>
      <near>0.1</near>
      <far>100</far>
    </clip>
  </camera>
  <always_on>1</always_on>
  <update_rate>30</update_rate>
  <visualize>true</visualize>
</sensor>
```

### LiDAR Sensors
```xml
<sensor name="lidar" type="ray">
  <pose>0.1 0 0.2 0 0 0</pose>
  <ray>
    <scan>
      <horizontal>
        <samples>360</samples>
        <resolution>1</resolution>
        <min_angle>-3.14159</min_angle>
        <max_angle>3.14159</max_angle>
      </horizontal>
    </scan>
    <range>
      <min>0.1</min>
      <max>30.0</max>
      <resolution>0.01</resolution>
    </range>
  </ray>
  <always_on>1</always_on>
  <update_rate>10</update_rate>
  <visualize>true</visualize>
</sensor>
```

### IMU Sensors
```xml
<sensor name="imu_sensor" type="imu">
  <always_on>1</always_on>
  <update_rate>100</update_rate>
  <visualize>false</visualize>
</sensor>
```

## Integrating with ROS 2

### Spawning Models in Gazebo
```bash
# Spawn a model at a specific pose
ros2 run gazebo_ros spawn_entity.py -entity my_robot -file /path/to/robot.sdf -x 0 -y 0 -z 0.5

# Spawn using topic
ros2 topic pub /spawn_entity gazebo_msgs/msg/SpawnEntity "{name: 'my_robot', xml: '<sdf>...</sdf>', initial_pose: {position: {x: 1, y: 1, z: 0.5}}}"
```

### Controlling Models via ROS 2
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import String

class GazeboController(Node):
    def __init__(self):
        super().__init__('gazebo_controller')
        self.publisher = self.create_publisher(Twist, '/cmd_vel', 10)
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

    def timer_callback(self):
        msg = Twist()
        msg.linear.x = 1.0
        msg.angular.z = 0.5
        self.publisher.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    controller = GazeboController()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Getting Model States
```bash
# Get model state
ros2 service call /gazebo/get_entity_state gazebo_msgs/srv/GetEntityState "{name: 'my_robot', reference_frame: ''}"
```

## Performance Optimization

### Simulation Parameters
- **Time Step**: Smaller steps increase accuracy but decrease performance
- **Update Rate**: Balance between responsiveness and computational load
- **Real-time Factor**: Adjust based on available computational resources

### Visualization Settings
- Disable visualization when running headless
- Reduce rendering quality for faster simulation
- Use simplified models for performance-critical scenarios

### Model Complexity
- Use simplified collision geometries when possible
- Reduce mesh complexity for faster rendering
- Optimize sensor update rates based on requirements

## Best Practices

1. **Start Simple**: Begin with basic models and gradually increase complexity
2. **Validate Physics**: Ensure physical parameters match real-world values
3. **Sensor Calibration**: Calibrate simulated sensors to match real hardware
4. **Performance Monitoring**: Monitor simulation timing and adjust parameters accordingly
5. **World Design**: Create worlds that match your testing requirements

## Troubleshooting Common Issues

### Simulation Instability
- Reduce time step size
- Adjust solver parameters
- Check mass and inertia values

### Performance Issues
- Simplify collision geometries
- Reduce sensor update rates
- Use appropriate physics engine

### Model Penetration
- Increase physics update rate
- Adjust ERP and CFM parameters
- Verify collision geometries

## Summary

Gazebo provides a comprehensive simulation environment for robotics development, offering realistic physics, sensor simulation, and integration with ROS 2. Proper world creation and physics configuration are crucial for effective simulation. The next chapter will explore NVIDIA Isaac Sim and its applications in reinforcement learning for robotics.